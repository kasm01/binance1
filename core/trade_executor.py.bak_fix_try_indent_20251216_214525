import logging
import os
from datetime import datetime
from typing import Optional, Dict, Any, Tuple

from config import config
from core.risk_manager import RiskManager
from core.position_manager import PositionManager

logger = logging.getLogger("system")


class TradeExecutor:
    """
    TradeExecutor:
      - RiskManager ile entegre
      - PositionManager ile açık pozisyon state'ini yönetir
      - ATR bazlı SL/TP + trailing stop uygular
      - Flip (long -> short, short -> long) durumunda PnL hesaplar
      - DRY_RUN modunda gerçek emir atmadan her şeyi simüle eder
    """

    def __init__(
        self,
        client: Optional[Any],
        risk_manager: RiskManager,
        position_manager: Optional[PositionManager] = None,
        logger: Optional[logging.Logger] = None,
        dry_run: bool = True,
        # temel risk parametreleri
        base_order_notional: float = 50.0,
        max_position_notional: float = 500.0,
        max_leverage: float = 3.0,
        # SL/TP & trailing
        sl_pct: float = 0.01,
        tp_pct: float = 0.02,
        trailing_pct: float = 0.01,
        use_atr_sltp: bool = True,
        atr_sl_mult: float = 1.5,
        atr_tp_mult: float = 3.0,
        # whale risk kancası
        whale_risk_boost: float = 2.0,
    ) -> None:
        self.client = client
        self.risk_manager = risk_manager
        self.position_manager = position_manager
        self.logger = logger or logging.getLogger("system")
        self.dry_run = bool(dry_run)

        self.base_order_notional = float(base_order_notional)
        self.max_position_notional = float(max_position_notional)
        self.max_leverage = float(max_leverage)

        self.sl_pct = float(sl_pct)
        self.tp_pct = float(tp_pct)
        self.trailing_pct = float(trailing_pct)
        self.use_atr_sltp = bool(use_atr_sltp)
        self.atr_sl_mult = float(atr_sl_mult)
        self.atr_tp_mult = float(atr_tp_mult)

        self.whale_risk_boost = float(whale_risk_boost)

        # Eğer PositionManager yoksa en basit fallback olarak in-memory dict
        self._local_positions: Dict[str, Dict[str, Any]] = {}

        self.logger.info(
            "[EXEC] TradeExecutor init | dry_run=%s base_order_notional=%.2f "
            "max_position_notional=%.2f",
            self.dry_run,
            self.base_order_notional,
            self.max_position_notional,
        )

    # ------------------------------------------------------------------
    #  Low-level position access (PositionManager varsa onu kullan)
    # ------------------------------------------------------------------
    def _get_position(self, symbol: str) -> Optional[Dict[str, Any]]:
        if self.position_manager is not None:
            try:
                return self.position_manager.get_position(symbol)
            except Exception as e:
                self.logger.warning(
                    "[EXEC] PositionManager.get_position hata: %s, local fallback kullanılacak.",
                    e,
                )
        return self._local_positions.get(symbol)

    def _set_position(self, symbol: str, pos: Dict[str, Any]) -> None:
        if self.position_manager is not None:
            try:
                self.position_manager.set_position(symbol, pos)
            except Exception as e:
                self.logger.warning(
                    "[EXEC] PositionManager.set_position hata: %s, local fallback'e yazılıyor.",
                    e,
                )
                self._local_positions[symbol] = pos
        else:
            self._local_positions[symbol] = pos

    def _clear_position(self, symbol: str) -> None:
        if self.position_manager is not None:
            try:
                self.position_manager.clear_position(symbol)
            except Exception as e:
                self.logger.warning(
                    "[EXEC] PositionManager.clear_position hata: %s, local fallback temizlenecek.",
                    e,
                )
        self._local_positions.pop(symbol, None)

    # ------------------------------------------------------------------
    #  Ortak pozisyon dict oluşturucu (ATR / yüzde SL-TP + meta + entry snapshot)
    # ------------------------------------------------------------------
    def _create_position_dict(
        self,
        signal: str,
        symbol: str,
        price: float,
        qty: float,
        notional: float,
        interval: str,
        probs: Dict[str, float],
        extra: Dict[str, Any],
    ) -> Tuple[Dict[str, Any], str]:
        opened_at = datetime.utcnow().isoformat()
        atr_value = float(extra.get("atr", 0.0) or 0.0)

        # --- SL/TP hesaplama ---
        if self.use_atr_sltp and atr_value > 0.0:
            if signal == "long":
                sl_price = price - self.atr_sl_mult * atr_value
                tp_price = price + self.atr_tp_mult * atr_value
            else:  # short
                sl_price = price + self.atr_sl_mult * atr_value
                tp_price = price - self.atr_tp_mult * atr_value
        else:
            if signal == "long":
                sl_price = price * (1.0 - self.sl_pct)
                tp_price = price * (1.0 + self.tp_pct)
            else:
                sl_price = price * (1.0 + self.sl_pct)
                tp_price = price * (1.0 - self.tp_pct)

        # Highest/Lowest (trailing için başlangıç)
        highest_price = price
        lowest_price = price

        pos: Dict[str, Any] = {
            "symbol": symbol,
            "side": signal,
            "qty": qty,
            "entry_price": price,
            "notional": notional,
            "interval": interval,
            "opened_at": opened_at,
            "sl_price": sl_price,
            "tp_price": tp_price,
            "trailing_pct": self.trailing_pct,
            "atr_value": atr_value,
            "highest_price": highest_price,
            "lowest_price": lowest_price,
            "meta": {
                "probs": probs,
                "extra": extra,
                "bt_p_buy_raw": extra.get("ensemble_p") if isinstance(extra, dict) else None,
                "bt_p_buy_ema": probs.get("p_single") if isinstance(probs, dict) else None,
                "bt_ema_alpha": None,

            },
        }


        # ------------------------------------------------------------------
        # ENTRY whale snapshot (for analysis / optimization)
        # ------------------------------------------------------------------
        try:
            entry_whale_dir = str(extra.get("whale_dir", "none") or "none")
            entry_whale_score = float(extra.get("whale_score", 0.0) or 0.0)
            entry_whale_thr = float(extra.get("whale_thr", 0.0) or 0.0)
            entry_whale_on = bool(extra.get("whale_on", False))
            entry_whale_alignment = str(
                extra.get("whale_alignment", "no_whale") or "no_whale"
            )
            entry_model_conf = float(extra.get("model_confidence_factor", 1.0) or 1.0)

            meta = pos.get("meta")
            if not isinstance(meta, dict):
                pos["meta"] = {}
                meta = pos["meta"]

            meta.update(
                {
                    "entry_whale_dir": entry_whale_dir,
                    "entry_whale_score": entry_whale_score,
                    "entry_whale_thr": entry_whale_thr,
                    "entry_whale_on": entry_whale_on,
                    "entry_whale_alignment": entry_whale_alignment,
                    "entry_model_confidence_factor": entry_model_conf,
                }
            )
        except Exception:
            pass

        return pos, opened_at


    # ------------------------------------------------------------------
    #  PnL hesaplayıcı (flip + close için)
    # ------------------------------------------------------------------
    @staticmethod
    def _calc_pnl(side: str, entry_price: float, exit_price: float, qty: float) -> float:
        if qty <= 0:
            return 0.0
        if side == "long":
            return (exit_price - entry_price) * qty
        if side == "short":
            return (entry_price - exit_price) * qty
        return 0.0

    # ------------------------------------------------------------------
    #  Pozisyon kapama helper (PnL + risk manager + state temizleme)
    # ------------------------------------------------------------------
    def _close_position(
        self,
        symbol: str,
        price: float,
        reason: str,
        interval: str,
    ) -> Optional[Dict[str, Any]]:
        pos = self._get_position(symbol)
        if not pos:
            return None

        side = pos["side"]
        qty = float(pos["qty"])
        entry_price = float(pos["entry_price"])
        notional = float(pos.get("notional", qty * entry_price))

        realized_pnl = self._calc_pnl(
            side=side, entry_price=entry_price, exit_price=price, qty=qty
        )

        self.logger.info(
            "[EXEC] Pozisyon kapatılıyor | symbol=%s side=%s qty=%.4f entry=%.2f exit=%.2f pnl=%.4f reason=%s",
            symbol,
            side,
            qty,
            entry_price,
            price,
            realized_pnl,
            reason,
        )

        if self.dry_run:
            self.logger.info("[EXEC] DRY_RUN=True, gerçek close emri gönderilmeyecek.")
        else:
            # TODO: Binance/OKX/KuCoin client ile close emri
            pass

        try:
            meta_dict = pos.get("meta") if isinstance(pos.get("meta"), dict) else {}

            self.risk_manager.on_position_close(
                symbol=symbol,
                side=side,
                qty=qty,
                notional=notional,
                price=price,
                interval=interval,
                realized_pnl=realized_pnl,
                meta={
                    "reason": reason,
                    "entry_price": entry_price,
                    "closed_side": side,
                    "interval": interval,
                    "qty": qty,
                    "notional": notional,
                    "probs": (pos.get("meta", {}).get("probs", {}) if isinstance(pos.get("meta", {}), dict) else {}),
                    "extra": (pos.get("meta", {}).get("extra", {}) if isinstance(pos.get("meta", {}), dict) else {}),
                    # --- EMA / ProbStabilizer fields (flatten for journal) ---
                    "bt_p_buy_raw": (pos.get("meta", {}) if isinstance(pos.get("meta", {}), dict) else {}).get("extra", {}).get("ensemble_p"),
                    "bt_p_buy_ema": (pos.get("meta", {}) if isinstance(pos.get("meta", {}), dict) else {}).get("probs", {}).get("p_single"),
                    "bt_ema_alpha": None,


                },
            )
        except Exception as e:
            self.logger.warning("[RISK] on_position_close hata: %s", e)

        self._clear_position(symbol)

        pos["closed_at"] = datetime.utcnow().isoformat()
        pos["close_price"] = price
        pos["realized_pnl"] = realized_pnl
        pos["close_reason"] = reason
        return pos

    # ------------------------------------------------------------------
    #  SL/TP + trailing stop kontrolleri
    # ------------------------------------------------------------------
    def _check_sl_tp_trailing(
        self,
        symbol: str,
        price: float,
        interval: str,
    ) -> Optional[Dict[str, Any]]:
        pos = self._get_position(symbol)
        if not pos:
            return None

        side = pos["side"]
        sl_price = float(pos["sl_price"])
        tp_price = float(pos["tp_price"])
        trailing_pct = float(pos.get("trailing_pct", 0.0))
        highest_price = float(pos.get("highest_price", price))
        lowest_price = float(pos.get("lowest_price", price))

        if side == "long":
            if price <= sl_price:
                return self._close_position(symbol, price, reason="SL_HIT", interval=interval)
            if price >= tp_price:
                return self._close_position(symbol, price, reason="TP_HIT", interval=interval)

            if trailing_pct > 0.0:
                if price > highest_price:
                    pos["highest_price"] = price
                    self._set_position(symbol, pos)
                    highest_price = price

                trail_sl = highest_price * (1.0 - trailing_pct)
                if price <= trail_sl:
                    return self._close_position(
                        symbol, price, reason="TRAILING_STOP_LONG", interval=interval
                    )

        elif side == "short":
            if price >= sl_price:
                return self._close_position(symbol, price, reason="SL_HIT", interval=interval)
            if price <= tp_price:
                return self._close_position(symbol, price, reason="TP_HIT", interval=interval)

            if trailing_pct > 0.0:
                if price < lowest_price:
                    pos["lowest_price"] = price
                    self._set_position(symbol, pos)
                    lowest_price = price

                trail_sl = lowest_price * (1.0 + trailing_pct)
                if price >= trail_sl:
                    return self._close_position(
                        symbol, price, reason="TRAILING_STOP_SHORT", interval=interval
                    )

        return None

    # ------------------------------------------------------------------
    #  Notional / qty hesaplama (whale + risk çarpanları dahil)
    # ------------------------------------------------------------------
    def _compute_notional(
        self,
        symbol: str,
        signal: str,
        price: float,
        extra: Dict[str, Any],
    ) -> float:
        """
        Agresif notional hesaplama:
          - base_order_notional
          - model_confidence_factor
          - whale (dir + score)  [direct keys + whale_meta fallback]
          - AGGRESSIVE_MODE / MAX_RISK_MULTIPLIER
          - max_position_notional clamp
        """

        aggressive_mode = bool(getattr(config, "AGGRESSIVE_MODE", True))
        max_risk_mult = float(getattr(config, "MAX_RISK_MULTIPLIER", 4.0))
        whale_boost_thr = float(getattr(config, "WHALE_STRONG_THR", 0.6))
        whale_veto_thr = float(getattr(config, "WHALE_VETO_THR", 0.6))

        base = float(self.base_order_notional)
        model_conf = float(extra.get("model_confidence_factor", 1.0) or 1.0)

        whale_dir = None
        whale_score = 0.0

        try:
            if isinstance(extra, dict):
                if extra.get("whale_dir") is not None:
                    whale_dir = extra.get("whale_dir")
                if extra.get("whale_score") is not None:
                    whale_score = float(extra.get("whale_score") or 0.0)

            whale_info = extra.get("whale_meta") or extra.get("whale")
            if isinstance(whale_info, dict):
                if whale_dir is None:
                    whale_dir = whale_info.get("direction") or whale_info.get("dir")
                if whale_score == 0.0:
                    whale_score = float(whale_info.get("score") or 0.0)
        except Exception:
            whale_dir = None
            whale_score = 0.0

        whale_dir = "none" if whale_dir is None else str(whale_dir).lower()

        aggr_factor = 1.0

        if aggressive_mode:
            if whale_score > 0.0 and whale_dir in ("long", "short"):
                if whale_dir == signal:
                    if whale_score >= whale_boost_thr:
                        aggr_factor += self.whale_risk_boost * max(
                            0.0, whale_score - whale_boost_thr
                        )
                else:
                    if whale_score >= whale_veto_thr:
                        aggr_factor -= 0.8 * whale_score
                    else:
                        aggr_factor -= 0.4 * whale_score

            mc = max(0.0, min(model_conf, 1.0))
            aggr_factor *= (0.5 + 0.5 * mc)

        aggr_factor = max(0.0, aggr_factor)
        aggr_factor = min(aggr_factor, max_risk_mult)

        notional = base * aggr_factor

        if notional > self.max_position_notional:
            notional = self.max_position_notional
        if notional < 10.0:
            notional = 10.0

        self.logger.info(
            "[EXEC] _compute_notional | symbol=%s signal=%s base=%.2f model_conf=%.2f "
            "whale_score=%.3f whale_dir=%s aggr_factor=%.3f final=%.2f",
            symbol,
            signal,
            base,
            model_conf,
            whale_score,
            whale_dir,
            aggr_factor,
            notional,
        )

        return notional

    # ------------------------------------------------------------------
    #  Ana karar fonksiyonu
    # ------------------------------------------------------------------
    async def execute_decision(
        self,
        signal: str,
        symbol: str,
        price: float,
        size: Optional[float],
        interval: str,
        training_mode: bool,
        hybrid_mode: bool,
        probs: Dict[str, float],
        extra: Optional[Dict[str, Any]] = None,
    ) -> None:

        # --------------------------------------------------
        # SHADOW MODE: trade yok, sadece log
        # --------------------------------------------------
        shadow = os.getenv("SHADOW_MODE", "false").lower() in ("1","true","yes","on")
        if shadow:
            if self.logger:
                self.logger.info(
                    "[SHADOW] signal=%s symbol=%s price=%.2f interval=%s probs=%s extra=%s",
                    signal,
                    symbol,
                    float(price),
                    interval,
                    probs,
                    extra,
                )
            return
        extra = extra or {}

        self.logger.info(
            "[EXEC] execute_decision çağrıldı | signal=%s symbol=%s price=%.2f size=%s interval=%s "
            "training_mode=%s hybrid_mode=%s probs=%s extra_keys=%s",
            signal,
            symbol,
            price,
            size,
            interval,
            training_mode,
            hybrid_mode,
            probs,
            list(extra.keys()),
        )

        if training_mode:
            self.logger.info(
                "[EXEC] TRAINING_MODE=True, sadece log. Herhangi bir pozisyon açma/kapama yapılmayacak."
            )
            return

        self._check_sl_tp_trailing(symbol=symbol, price=price, interval=interval)

        current_pos = self._get_position(symbol)
        current_side = current_pos["side"] if current_pos else None

        if signal == "hold":
            self.logger.info("[EXEC] Sinyal=HOLD, yeni pozisyon açılmayacak / flip edilmeyecek.")
            return

        if size is not None and size > 0:
            qty = float(size)
            notional = qty * price
        else:
            notional = self._compute_notional(
                symbol=symbol, signal=signal, price=price, extra=extra
            )
            qty = notional / price

        allowed = True
        if self.risk_manager is not None:
            try:
                allowed = self.risk_manager.can_open_new_trade(
                    symbol=symbol,
                    side=signal,
                    notional=notional,
                    price=price,
                    interval=interval,
                    meta={"has_position": bool(current_pos)},
                )
            except Exception as e:
                self.logger.warning("[RISK] can_open_new_trade hata: %s, default=True", e)
                allowed = True

        if not allowed:
            self.logger.info(
                "[RISK] can_open_new_trade=False | symbol=%s side=%s notional=%.2f -> trade açılmadı.",
                symbol,
                signal,
                notional,
            )
            return

        # --------------------------------------------------------------
        # Pozisyon yok → yeni pozisyon aç
        # --------------------------------------------------------------
        if current_pos is None:
            if signal in ("long", "short"):
                self.logger.info(
                    "[EXEC] Yeni pozisyon açılıyor | symbol=%s side=%s qty=%.4f notional=%.2f price=%.2f",
                    symbol,
                    signal,
                    qty,
                    notional,
                    price,
                )

                if self.dry_run:
                    self.logger.info(
                        "[EXEC] DRY_RUN=True, gerçek açılış emri gönderilmeyecek (sadece state+log)."
                    )
                else:
                    # TODO: Borsaya market/limit order gönder
                    pass

                pos, opened_at = self._create_position_dict(
                    signal=signal,
                    symbol=symbol,
                    price=price,
                    qty=qty,
                    notional=notional,
                    interval=interval,
                    probs=probs,
                    extra=extra,
                )
                self._set_position(symbol, pos)
                try:
                self.risk_manager.on_position_open(
                    symbol=symbol,
                    side=signal,
                    qty=qty,
                    notional=notional,
                    price=price,
                    interval=interval,
                    meta=(lambda _m: (_m.update({'opened_at': opened_at, 'source': 'TradeExecutor'}) or _m))(
                        dict(pos.get('meta', {})) if isinstance(pos.get('meta', {}), dict) else {}
                    ),
                )
                            dict(pos.get("meta", {})) if isinstance(pos.get("meta", {}), dict) else {}
                        ),
                    )
                   self.risk_manager.on_position_open(

            return

        # --------------------------------------------------------------
        # Zaten pozisyon var → aynı yön ise hold, ters ise flip
        # --------------------------------------------------------------
        if current_side == signal:
            self.logger.info(
                "[EXEC] Mevcut pozisyon sinyal ile aynı yönde (side=%s), scale-in yapılmıyor, sadece HOLD.",
                current_side,
            )
            return

        self.logger.info(
            "[EXEC] Flip sinyali | symbol=%s current_side=%s new_side=%s",
            symbol,
            current_side,
            signal,
        )

        self._close_position(
            symbol=symbol,
            price=price,
            reason="FLIP_CLOSE",
            interval=interval,
        )

        self.logger.info(
            "[EXEC] Flip sonrası yeni pozisyon açılıyor | symbol=%s side=%s qty=%.4f notional=%.2f price=%.2f",
            symbol,
            signal,
            qty,
            notional,
            price,
        )

        if self.dry_run:
            self.logger.info(
                "[EXEC] DRY_RUN=True, flip sonrası gerçek açılış emri gönderilmeyecek (sadece state+log)."
            )
        else:
            # TODO: Borsaya yeni pozisyon emri gönder
            pass

        new_pos, opened_at = self._create_position_dict(
            signal=signal,
            symbol=symbol,
            price=price,
            qty=qty,
            notional=notional,
            interval=interval,
            probs=probs,
            extra=extra,
        )
        self._set_position(symbol, new_pos)

        try:
            self.risk_manager.on_position_open(
                symbol=symbol,
                side=signal,
                qty=qty,
                notional=notional,
                price=price,
                interval=interval,
                meta=(lambda _m: (_m.update({"opened_at": opened_at, "source": "TradeExecutor_flip"}) or _m))(dict(pos.get("meta", {})) if isinstance(pos.get("meta", {}), dict) else {}),
            )
        except Exception as e:
            self.logger.warning("[RISK] on_position_open (flip) hata: %s", e)
