import os
import asyncio
import logging
from typing import Dict, Any, Optional, List

import pandas as pd
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass

from config.load_env import load_environment_variables
from core.logger import setup_logger
from core.risk_manager import RiskManager
from core.trade_executor import TradeExecutor
from models.hybrid_inference import HybridModel
from core.hybrid_mtf import MultiTimeframeHybridEnsemble
from data.whale_detector import MultiTimeframeWhaleDetector
from data.anomaly_detection import AnomalyDetector

# main.py helper'ları
from main import build_features, compute_atr_from_klines, build_labels


# ==========================================================
# Backtest Stats
# ==========================================================
@dataclass
class BacktestStats:
    starting_equity: float = 1000.0
    equity: float = 1000.0
    peak_equity: float = 1000.0
    max_drawdown: float = 0.0
    n_trades: int = 0
    n_wins: int = 0
    n_losses: int = 0

    def on_pnl_delta(self, delta: float) -> None:
        if delta == 0.0:
            return

        self.equity += delta
        self.peak_equity = max(self.peak_equity, self.equity)

        if self.peak_equity > 0:
            dd = (self.peak_equity - self.equity) / self.peak_equity
            self.max_drawdown = max(self.max_drawdown, dd)

        self.n_trades += 1
        if delta > 0:
            self.n_wins += 1
        else:
            self.n_losses += 1

    def summary_dict(self) -> Dict[str, float]:
        pnl = self.equity - self.starting_equity
        return {
            "starting_equity": self.starting_equity,
            "ending_equity": self.equity,
            "pnl": pnl,
            "pnl_pct": (pnl / self.starting_equity) * 100 if self.starting_equity else 0.0,
            "n_trades": self.n_trades,
            "n_wins": self.n_wins,
            "n_losses": self.n_losses,
            "winrate": (self.n_wins / self.n_trades) * 100 if self.n_trades else 0.0,
            "max_drawdown_pct": self.max_drawdown * 100.0,
        }


# ==========================================================
# Globals
# ==========================================================
system_logger: Optional[logging.Logger] = None
MTF_INTERVALS = ["1m", "5m", "15m", "1h"]

# main.py ile uyumlu feature set (p=0.5 kilitlenmesini önlemede kritik)
FEATURE_COLS = [
    "open_time",
    "open",
    "high",
    "low",
    "close",
    "volume",
    "close_time",
    "quote_asset_volume",
    "number_of_trades",
    "taker_buy_base_volume",
    "taker_buy_quote_volume",
    "ignore",
    "hl_range",
    "oc_change",
    "return_1",
    "return_3",
    "return_5",
    "ma_5",
    "ma_10",
    "ma_20",
    "vol_10",
    "dummy_extra",
]


def get_bool_env(name: str, default: bool = False) -> bool:
    v = os.getenv(name)
    return default if v is None else str(v).strip().lower() in ("1", "true", "yes", "on")


# ==========================================================
# Offline kline loader
# ==========================================================
def load_offline_klines(symbol: str, interval: str, limit: Optional[int]) -> pd.DataFrame:
    path = f"data/offline_cache/{symbol}_{interval}_6m.csv"
    if not os.path.exists(path):
        raise FileNotFoundError(path)

    df = pd.read_csv(path)
    if limit and len(df) > limit:
        df = df.tail(limit).reset_index(drop=True)
    return df


def _safe_bar_time_iso(raw_df: pd.DataFrame, i: int) -> str:
    if "open_time" not in raw_df.columns:
        return str(i)
    try:
        ot = raw_df["open_time"].iloc[i]
        if pd.isna(ot):
            return str(i)
        return datetime.utcfromtimestamp(float(ot) / 1000.0).isoformat()
    except Exception:
        return str(i)


def _extract_mtf_p_last(mtf_debug: Any, itv: str) -> Optional[float]:
    try:
        if not isinstance(mtf_debug, dict):
            return None
        per = mtf_debug.get("per_interval", {})
        if not isinstance(per, dict):
            return None
        d = per.get(itv, {})
        if not isinstance(d, dict):
            return None
        v = d.get("p_last", None)
        return float(v) if v is not None else None
    except Exception:
        return None


def _prep_X(feat_df: pd.DataFrame) -> pd.DataFrame:
    """
    Model input güvenliği:
      - FEATURE_COLS intersection
      - numeric coercion
      - NaN/inf temizliği
    """
    cols = [c for c in FEATURE_COLS if c in feat_df.columns]
    if not cols:
        return pd.DataFrame()

    X = feat_df[cols].copy()
    X = X.apply(pd.to_numeric, errors="coerce")
    X = X.replace([float("inf"), float("-inf")], pd.NA).fillna(0.0)
    return X


# ==========================================================
# Backtest Core
# ==========================================================
async def run_backtest() -> None:
    global system_logger

    symbol = os.getenv("BT_SYMBOL", "BTCUSDT")
    main_interval = os.getenv("BT_MAIN_INTERVAL", "5m")
    data_limit = int(os.getenv("BT_DATA_LIMIT", "500"))

    HYBRID_MODE = get_bool_env("HYBRID_MODE", True)
    USE_MTF_ENS = get_bool_env("USE_MTF_ENS", True)

    warmup = int(os.getenv("BT_WARMUP_BARS", "200"))
    atr_period = int(os.getenv("ATR_PERIOD", "14"))
    long_thr = float(os.getenv("LONG_THRESHOLD", "0.60"))
    short_thr = float(os.getenv("SHORT_THRESHOLD", "0.40"))

    USE_WHALE_FILTER = get_bool_env("BT_USE_WHALE_FILTER", False)
    WHALE_THR = float(os.getenv("BT_WHALE_THR", "0.50"))
    WHALE_MODE = os.getenv("BT_WHALE_MODE", "block_opposed").strip().lower()
    # WHALE_MODE: block_opposed | only_aligned

    if main_interval not in MTF_INTERVALS:
        raise ValueError(f"BT_MAIN_INTERVAL={main_interval} MTF_INTERVALS içinde olmalı: {MTF_INTERVALS}")

    system_logger.info(
        "[BT] Backtest başlıyor | symbol=%s main_interval=%s HYBRID_MODE=%s USE_MTF_ENS=%s",
        symbol,
        main_interval,
        HYBRID_MODE,
        USE_MTF_ENS,
    )

    # --------------------------------------------------
    # Load data + features + anomaly
    # --------------------------------------------------
    anomaly_detector = AnomalyDetector(logger=system_logger)
    raw_by_interval: Dict[str, pd.DataFrame] = {}
    feat_by_interval: Dict[str, pd.DataFrame] = {}

    alias_map = {
        "taker_buy_base_volume": "taker_buy_base_asset_volume",
        "taker_buy_quote_volume": "taker_buy_quote_asset_volume",
    }

    for itv in MTF_INTERVALS:
        raw = load_offline_klines(symbol, itv, data_limit)
        feat = build_features(raw)

        for old_col, new_col in alias_map.items():
            if old_col not in feat.columns and new_col in feat.columns:
                feat[old_col] = feat[new_col]

        feat = anomaly_detector.filter_anomalies(feat)

        raw_by_interval[itv] = raw.reset_index(drop=True)
        feat_by_interval[itv] = feat.reset_index(drop=True)

    min_len = min(len(v) for v in feat_by_interval.values())
    if min_len < 200:
        raise RuntimeError(f"Backtest için veri yetersiz (min_len={min_len})")

    if warmup >= min_len:
        warmup = max(50, min_len // 3)

    # --------------------------------------------------
    # Models
    # --------------------------------------------------
    mtf_models: Dict[str, HybridModel] = {}
    main_model: Optional[HybridModel] = None

    for itv in MTF_INTERVALS:
        m = HybridModel(model_dir="models", interval=itv, logger=system_logger)
        try:
            if hasattr(m, "use_lstm_hybrid"):
                m.use_lstm_hybrid = HYBRID_MODE
        except Exception:
            pass

        mtf_models[itv] = m
        system_logger.info("[BT] HybridModel yüklendi | interval=%s", itv)
        if itv == main_interval:
            main_model = m

    if main_model is None:
        raise RuntimeError("Main interval için HybridModel bulunamadı.")

    mtf_ensemble = MultiTimeframeHybridEnsemble(mtf_models)

    whale_detector: Optional[MultiTimeframeWhaleDetector] = None
    try:
        whale_detector = MultiTimeframeWhaleDetector()
        system_logger.info("[BT-WHALE] MultiTimeframeWhaleDetector init OK")
    except Exception as e:
        system_logger.warning("[BT-WHALE] init hata: %s (whale kapalı)", e)
        whale_detector = None

    # --------------------------------------------------
    # Risk & Executor
    # --------------------------------------------------
    equity_start_of_day = float(os.getenv("BT_EQUITY_START_OF_DAY", "1000"))
    risk_manager = RiskManager(
        daily_max_loss_usdt=float(os.getenv("BT_DAILY_MAX_LOSS_USDT", "100")),
        daily_max_loss_pct=float(os.getenv("BT_DAILY_MAX_LOSS_PCT", "0.03")),
        max_consecutive_losses=int(os.getenv("BT_MAX_CONSECUTIVE_LOSSES", "5")),
        max_open_trades=int(os.getenv("BT_MAX_OPEN_TRADES", "3")),
        equity_start_of_day=equity_start_of_day,
        logger=system_logger,
    )

    trade_executor = TradeExecutor(
        client=None,
        risk_manager=risk_manager,
        position_manager=None,
        logger=system_logger,
        dry_run=True,
        base_order_notional=float(os.getenv("BT_BASE_ORDER_NOTIONAL", "50")),
        max_position_notional=float(os.getenv("BT_MAX_POSITION_NOTIONAL", "500")),
        max_leverage=float(os.getenv("BT_MAX_LEVERAGE", "3")),
        sl_pct=float(os.getenv("BT_SL_PCT", "0.01")),
        tp_pct=float(os.getenv("BT_TP_PCT", "0.02")),
        trailing_pct=float(os.getenv("BT_TRAILING_PCT", "0.01")),
        use_atr_sltp=get_bool_env("BT_USE_ATR_SLTP", True),
        atr_sl_mult=float(os.getenv("BT_ATR_SL_MULT", "1.5")),
        atr_tp_mult=float(os.getenv("BT_ATR_TP_MULT", "3.0")),
        whale_risk_boost=float(os.getenv("BT_WHALE_RISK_BOOST", "2.0")),
    )

    # --------------------------------------------------
    # CSV Buffers + bt_context (TRADES içine whale_* direkt gidecek)
    # --------------------------------------------------
    equity_rows: List[Dict[str, Any]] = []
    closed_trades: List[Dict[str, Any]] = []

    bt_context: Dict[str, Any] = {
        "bar": None,
        "time": None,
        "signal": None,
        "price": None,
        "p_used": None,
        "p_single": None,
        "p_1m": None,
        "p_5m": None,
        "p_15m": None,
        "p_1h": None,
        "whale_dir": None,
        "whale_score": None,
        "atr": None,
    }

    # Patch close_position → closed_trades’e whale_score/dir + bt_* ekle
    if hasattr(trade_executor, "_close_position"):
        try:
            orig = trade_executor._close_position  # type: ignore[attr-defined]

            def patched(symbol: str, price: float, reason: str, interval: str):
                closed = orig(symbol=symbol, price=price, reason=reason, interval=interval)
                if isinstance(closed, dict):
                    closed["bt_symbol"] = symbol
                    closed["bt_interval"] = interval

                    closed["bt_bar"] = bt_context.get("bar")
                    closed["bt_time"] = bt_context.get("time")
                    closed["bt_signal"] = bt_context.get("signal")
                    closed["bt_price"] = bt_context.get("price")
                    closed["bt_p_used"] = bt_context.get("p_used")
                    closed["bt_p_single"] = bt_context.get("p_single")
                    closed["bt_p_1m"] = bt_context.get("p_1m")
                    closed["bt_p_5m"] = bt_context.get("p_5m")
                    closed["bt_p_15m"] = bt_context.get("p_15m")
                    closed["bt_p_1h"] = bt_context.get("p_1h")

                    # İstenen: trades csv’de whale_* direkt olsun
                    closed["whale_dir"] = bt_context.get("whale_dir")
                    closed["whale_score"] = bt_context.get("whale_score")

                    closed["bt_atr"] = bt_context.get("atr")

                    closed_trades.append(closed)
                return closed

            trade_executor._close_position = patched  # type: ignore[method-assign]
            system_logger.info("[BT] TradeExecutor._close_position patch OK (trades içine whale_* yazılacak).")
        except Exception as e:
            system_logger.warning("[BT] TradeExecutor patch başarısız (trades whale_* eksik olabilir): %s", e)
    else:
        system_logger.warning("[BT] TradeExecutor içinde _close_position yok. trades whale_* yakalama pasif.")

    bt_stats = BacktestStats(
        starting_equity=equity_start_of_day,
        equity=equity_start_of_day,
        peak_equity=equity_start_of_day,
    )

    # --------------------------------------------------
    # Loop
    # --------------------------------------------------
    system_logger.info("[BT] warmup=%d min_len=%d long_thr=%.3f short_thr=%.3f", warmup, min_len, long_thr, short_thr)

    for i in range(warmup, min_len - 1):
        try:
            # 500 bar slice
            X_by_interval: Dict[str, pd.DataFrame] = {}
            mtf_whale_raw: Dict[str, pd.DataFrame] = {}

            for itv in MTF_INTERVALS:
                feat_slice_full = feat_by_interval[itv].iloc[: i + 1]
                raw_slice = raw_by_interval[itv].iloc[: i + 1]

                X = _prep_X(feat_slice_full).tail(500)
                if X.empty:
                    continue

                X_by_interval[itv] = X
                mtf_whale_raw[itv] = raw_slice.tail(500)

            if main_interval not in X_by_interval:
                continue

            # single proba (main interval)
            p_arr, debug = main_model.predict_proba(X_by_interval[main_interval])
            p_single = float(p_arr[-1])
            p_used = p_single
            mtf_debug = None

            if USE_MTF_ENS:
                try:
                    ens_p, mtf_debug = mtf_ensemble.predict_mtf(X_by_interval)
                    p_used = float(ens_p)
                except Exception as e:
                    system_logger.warning("[BT-MTF] predict_mtf hata: %s (fallback single)", e)
                    p_used = p_single
                    mtf_debug = None

            # per-tf probs
            p_1m = _extract_mtf_p_last(mtf_debug, "1m")
            p_5m = _extract_mtf_p_last(mtf_debug, "5m")
            p_15m = _extract_mtf_p_last(mtf_debug, "15m")
            p_1h = _extract_mtf_p_last(mtf_debug, "1h")

            # signal
            signal = "hold"
            if p_used >= long_thr:
                signal = "long"
            elif p_used <= short_thr:
                signal = "short"

            # whale meta
            whale_dir = "none"
            whale_score = 0.0
            if whale_detector is not None:
                try:
                    if hasattr(whale_detector, "analyze_multiple_timeframes"):
                        whale_signals = whale_detector.analyze_multiple_timeframes(mtf_whale_raw)
                        best_tf = None
                        best_score = 0.0
                        best_dir = "none"

                        for tf, sig in whale_signals.items():
                            s_dir = str(getattr(sig, "direction", "none"))
                            s_score = float(getattr(sig, "score", 0.0) or 0.0)
                            if s_dir != "none" and s_score > best_score:
                                best_score = s_score
                                best_tf = tf
                                best_dir = s_dir

                        if best_tf is not None:
                            whale_dir = best_dir
                            whale_score = best_score
                except Exception as e:
                    system_logger.warning("[BT-WHALE] analyze hata: %s", e)

            # ----------------------------------------------------------
            #  Whale Filter (opsiyonel)
            # ----------------------------------------------------------
            if USE_WHALE_FILTER and whale_score is not None:
                try:
                    ws = float(whale_score)
                except Exception:
                    ws = 0.0

                if ws >= WHALE_THR:
                    wd = str(whale_dir or "none").lower()

                    # trade_side: long/short
                    trade_side = signal
                    # whale_side: buy/sell
                    whale_side = "none"
                    if wd in ("buy", "long", "up"):
                        whale_side = "buy"
                    elif wd in ("sell", "short", "down"):
                        whale_side = "sell"

                    aligned = (
                        (trade_side == "long" and whale_side == "buy") or
                        (trade_side == "short" and whale_side == "sell")
                    )
                    opposed = (
                        (trade_side == "long" and whale_side == "sell") or
                        (trade_side == "short" and whale_side == "buy")
                    )

                    if WHALE_MODE == "only_aligned":
                        # whale güçlü ise sadece aligned trade'e izin ver
                        if signal in ("long", "short") and not aligned:
                            system_logger.info(
                                "[BT-WHALE_FILTER] %s -> HOLD | strong_whale ws=%.3f wd=%s mode=only_aligned",
                                signal, ws, wd
                            )
                            signal = "hold"

                    else:
                        # default: block_opposed
                        if signal in ("long", "short") and opposed:
                            system_logger.info(
                                "[BT-WHALE_FILTER] %s -> HOLD | opposed_whale ws=%.3f wd=%s mode=block_opposed",
                                signal, ws, wd
                            )
                            signal = "hold"
                # else: whale zayıf/off → dokunma

            # ATR
            raw_main = raw_by_interval[main_interval].iloc[: i + 1]
            atr_value = compute_atr_from_klines(raw_main.tail(atr_period + 2), period=atr_period)

            # price/time
            price = float(raw_by_interval[main_interval]["close"].iloc[i])
            bar_time = _safe_bar_time_iso(raw_by_interval[main_interval], i)

            # ---- bt_context güncelle (KAPANIŞ ANINDA trades'e yazılacak) ----
            bt_context.update(
                {
                    "bar": i,
                    "time": bar_time,
                    "signal": signal,
                    "price": price,
                    "p_used": float(p_used),
                    "p_single": float(p_single),
                    "p_1m": p_1m,
                    "p_5m": p_5m,
                    "p_15m": p_15m,
                    "p_1h": p_1h,
                    "whale_dir": whale_dir,
                    "whale_score": float(whale_score),
                    "atr": float(atr_value) if atr_value is not None else None,
                }
            )

            # pnl before
            prev_pnl = 0.0
            try:
                prev_pnl = float(getattr(risk_manager, "daily_realized_pnl", 0.0) or 0.0)
            except Exception:
                prev_pnl = 0.0

            await trade_executor.execute_decision(
                signal=signal,
                symbol=symbol,
                price=price,
                size=None,
                interval=main_interval,
                training_mode=False,
                hybrid_mode=HYBRID_MODE,
                probs={"p_used": float(p_used), "p_single": float(p_single)},
                extra={
                    "mtf_debug": mtf_debug,
                    "whale_dir": whale_dir,
                    "whale_score": float(whale_score),
                    "atr": float(atr_value) if atr_value is not None else None,
                },
            )

            # pnl after
            try:
                new_pnl = float(getattr(risk_manager, "daily_realized_pnl", prev_pnl) or prev_pnl)
            except Exception:
                new_pnl = prev_pnl

            delta = new_pnl - prev_pnl
            if delta != 0.0:
                bt_stats.on_pnl_delta(delta)

            equity_rows.append(
                {
                    "bar": i,
                    "time": bar_time,
                    "symbol": symbol,
                    "interval": main_interval,
                    "price": price,
                    "signal": signal,
                    "p_used": float(p_used),
                    "p_single": float(p_single),
                    "p_1m": p_1m,
                    "p_5m": p_5m,
                    "p_15m": p_15m,
                    "p_1h": p_1h,
                    "whale_dir": whale_dir,
                    "whale_score": float(whale_score),
                    "atr": float(atr_value) if atr_value is not None else None,
                    "equity": float(bt_stats.equity),
                    "peak_equity": float(bt_stats.peak_equity),
                    "max_drawdown_pct": float(bt_stats.max_drawdown) * 100.0,
                    "pnl_total": float(bt_stats.equity - bt_stats.starting_equity),
                }
            )

        except Exception as e:
            system_logger.exception("[BT-LOOP-ERROR] bar=%d hata=%s", i, e)

    # --------------------------------------------------
    # Export CSV
    # --------------------------------------------------
    out_dir = Path(os.getenv("BT_OUT_DIR", "outputs"))
    out_dir.mkdir(parents=True, exist_ok=True)

    tag = datetime.utcnow().strftime("%Y%m%d_%H%M%S")

    equity_path = out_dir / f"equity_curve_{symbol}_{main_interval}_{tag}.csv"
    trades_path = out_dir / f"trades_{symbol}_{main_interval}_{tag}.csv"
    summary_path = out_dir / f"summary_{symbol}_{main_interval}_{tag}.csv"

    pd.DataFrame(equity_rows).to_csv(equity_path, index=False)
    pd.DataFrame(closed_trades).to_csv(trades_path, index=False)
    pd.DataFrame([bt_stats.summary_dict()]).to_csv(summary_path, index=False)

    system_logger.info("[BT-CSV] equity_curve: %s (rows=%d)", str(equity_path), len(equity_rows))
    system_logger.info("[BT-CSV] trades:      %s (trades=%d)", str(trades_path), len(closed_trades))
    system_logger.info("[BT-CSV] summary:     %s", str(summary_path))


# ==========================================================
# Entry
# ==========================================================
async def async_main() -> None:
    global system_logger
    load_environment_variables()
    setup_logger()
    system_logger = logging.getLogger("system")
    await run_backtest()


def main() -> None:
    asyncio.run(async_main())


if __name__ == "__main__":
    main()
