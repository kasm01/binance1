"""
main.py
Binance futures trading bot entrypoint (LIVE + HybridModel entegrasyonu).

Bileşenler:
- Data pipeline (fetch klines + feature engineering + anomaly filter)
- OnlineLearner (SGD) + FallbackModel
- HybridModel (LSTM + SGD hibrit)
- RiskManager + PositionManager + TradeExecutor
- Async bot_loop (Cloud Run / VM için ortak)
"""

import asyncio
import json
import os
import signal
import sys
from pathlib import Path
from typing import Any, Dict

# ──────────────── Proje import'ları ────────────────

from config.load_env import load_environment_variables
from config.settings import Config

from core.logger import setup_logger, system_logger

from data.feature_engineer import FeatureEngineer
from data.anomaly_detection import AnomalyDetector
from data.online_learning import OnlineLearner

from models.fallback_model import FallbackModel
from models.hybrid_inference import HybridModel  # DİKKAT: models.__init__ değil, direkt modul!

from trading.risk_manager import RiskManager
from trading.position_manager import PositionManager
from trading.trade_executor import TradeExecutor


from binance.client import Client as BinanceClient  # gerçek Binance client


# ──────────────── Yardımcı fonksiyonlar ────────────────


def create_binance_client(config: Config) -> BinanceClient:
    """
    Binance futures client oluşturur.
    DRY_RUN modunda sadece kullanılan endpoint'leri test etmek için kullanılır.
    """
    api_key = os.getenv("BINANCE_API_KEY", "")
    api_secret = os.getenv("BINANCE_API_SECRET", "")

    if not api_key or not api_secret:
        system_logger.warning(
            "[BINANCE] API key/secret env'de yok. DRY_RUN modunda çalıştığından emin ol."
        )

    client = BinanceClient(api_key=api_key, api_secret=api_secret)
    return client


def create_trading_objects() -> Dict[str, Any]:
    """
    Tüm ana bileşenleri (data, modeller, trade executor, risk, vs.) initialize eder.
    Cloud Run ve VM için ortaktır.
    """
    # Env & Config yükle
    load_environment_variables()
    config = Config()

    # Logger
    setup_logger()  # system_logger'ı konfigure eder

    # Binance client
    binance_client = create_binance_client(config)

    feature_engineer = FeatureEngineer()
    anomaly_detector = AnomalyDetector()

    # Online model + fallback
    online_learner = OnlineLearner(
        model_dir="models",
        base_model_name="online_model",
        n_classes=2,
    )

    fallback_model = FallbackModel(default_proba=0.5)

    # Hibrit model (LSTM + SGD)
    interval_env = os.environ.get("INTERVAL", config.INTERVAL)
    hybrid_model = HybridModel(
        interval=interval_env,
        model_dir="models",
        alpha=0.6,  # p_hybrid = alpha * p_lstm + (1 - alpha) * p_sgd
        logger=system_logger,
    )

    # Risk & pozisyon yönetimi
    risk_manager = RiskManager(
        max_risk_per_trade=config.MAX_RISK_PER_TRADE,
        max_daily_loss_pct=config.MAX_DAILY_LOSS_PCT,
        state_file=os.path.join("logs", "risk_state.json"),
    )

    # Model AUC'ye göre risk çarpanı ayarla (offline pretrain meta dosyasından)
    interval_env = os.environ.get("INTERVAL", config.INTERVAL)
    meta_path = Path("models") / f"model_meta_{interval_env}.json"

    if meta_path.exists():
        try:
            with meta_path.open("r", encoding="utf-8") as f:
                meta = json.load(f)
            best_auc = float(meta.get("best_auc", 0.60))

            # RiskManager'da update_model_confidence varsa dinamik çarpanı ayarla
            if hasattr(risk_manager, "update_model_confidence"):
                risk_manager.update_model_confidence(best_auc)
                system_logger.info(
                    f"[RISK] Model AUC={best_auc:.4f} okundu, "
                    f"model_confidence_factor={risk_manager.model_confidence_factor:.2f}"
                )
            else:
                system_logger.info(
                    f"[RISK] Model AUC={best_auc:.4f} okundu "
                    "(RiskManager'da model_confidence_factor desteği yok)."
                )
        except Exception as e:
            system_logger.warning(f"[RISK] model_meta dosyası okunurken hata: {e!r}")
    else:
        system_logger.warning(
            f"[RISK] model_meta_{interval_env}.json bulunamadı, "
            "model_confidence_factor=1.0 kullanılacak."
        )

    # Pozisyon & trade executor
    position_manager = PositionManager()

    trade_executor = TradeExecutor(
        client=binance_client,
        risk_manager=risk_manager,
        position_manager=position_manager,
        config=config,
    )

    trading_objects: Dict[str, Any] = {
        "config": config,
        "binance_client": binance_client,
        "feature_engineer": feature_engineer,
        "anomaly_detector": anomaly_detector,
        "online_learner": online_learner,
        "fallback_model": fallback_model,
        "hybrid_model": hybrid_model,
        "risk_manager": risk_manager,
        "position_manager": position_manager,
        "trade_executor": trade_executor,
    }
    return trading_objects


# ──────────────── Pozisyon yönetimi ────────────────


def manage_positions_for_signal(
    symbol: str,
    signal: str,
    current_price: float,
    trade_executor: TradeExecutor,
    position_manager: PositionManager,
) -> None:
    """
    BUY / SELL / HOLD sinyaline göre pozisyon aç/kapat lojik.
    """
    long_pos = position_manager.get_position(symbol, "LONG")
    short_pos = position_manager.get_position(symbol, "SHORT")

    if signal == "BUY":
        # SHORT varsa kapat, LONG yoksa aç
        if short_pos is not None:
            trade_executor.close_position(symbol, "SHORT", current_price)
        if long_pos is None:
            trade_executor.open_position_from_signal(symbol, "LONG", current_price)

    elif signal == "SELL":
        # LONG varsa kapat, SHORT yoksa aç
        if long_pos is not None:
            trade_executor.close_position(symbol, "LONG", current_price)
        if short_pos is None:
            trade_executor.open_position_from_signal(symbol, "SHORT", current_price)

    else:  # HOLD
        system_logger.info("[MAIN] HOLD signal -> no new position opened/closed.")


# ──────────────── Ana async loop (ONLINE + HYBRID inference) ────────────────


async def bot_loop(trading_objects: Dict[str, Any]) -> None:
    config: Config = trading_objects["config"]
    feature_engineer: FeatureEngineer = trading_objects["feature_engineer"]
    anomaly_detector: AnomalyDetector = trading_objects["anomaly_detector"]
    online_learner: OnlineLearner = trading_objects["online_learner"]
    hybrid_model: HybridModel = trading_objects["hybrid_model"]
    risk_manager: RiskManager = trading_objects["risk_manager"]
    position_manager: PositionManager = trading_objects["position_manager"]
    trade_executor: TradeExecutor = trading_objects["trade_executor"]

    symbol = config.SYMBOL
    interval = config.INTERVAL

    LOOP_SLEEP_SECONDS = getattr(config, "LOOP_SLEEP_SECONDS", 60)
    N_SEQ = 100  # LSTM için kullanılacak bar sayısı (hibrit modelin seq uzunluğu)

    while True:
        try:
            system_logger.info(
                f"[DATA] Starting data pipeline for {symbol} ({interval}, limit=500)"
            )

            # 1) Veri çek
            system_logger.info("[DATA] Raw DF shape: %s", raw_df.shape)

            # 2) Feature engineering
            features_df = feature_engineer.build_live_features(raw_df)
            system_logger.info(
                "[FE] Features DF shape: %s, columns=%s",
                features_df.shape,
                list(features_df.columns),
            )

            # 3) Anomali filtresi
            clean_df = anomaly_detector.filter_anomalies(features_df)
            system_logger.info(
                "[ANOM] After anomaly filter: %d rows remain.", len(clean_df)
            )

            if len(clean_df) < max(N_SEQ + 20, 120):
                system_logger.warning(
                    "[DATA] Not enough rows after anomaly filter, skipping this loop."
                )
                await asyncio.sleep(LOOP_SLEEP_SECONDS)
                continue

            # 4) Online öğrenme için mini-batch (örnek, son 120 satırdan 100 tanesi)
            try:
                batch_df = clean_df.tail(120).head(100)
                online_learner.partial_update(batch_df)
            except Exception as e:
                system_logger.exception(
                    "[ONLINE] partial_update failed (ignored): %r", e
                )

            # 5) SGD (tabular) + LSTM (sekans) + hibrit skor
            last_row = clean_df.iloc[[-1]]   # shape (1, n_features)
            seq_df = clean_df.tail(N_SEQ)    # shape (N_SEQ, n_features)

            # 5a) SGD proba
            try:
                proba_sgd = online_learner.predict_proba(last_row)
                p_sgd = float(proba_sgd[0, 1])
            except Exception as e:
                system_logger.exception(
                    "[ONLINE] SGD predict_proba failed, falling back to 0.5: %r", e
                )
                p_sgd = 0.5

            # 5b) HYBRID: HybridModel.predict_proba (LSTM + SGD)
            try:
                # HybridModel.predict_proba:
                #   return p_hybrid, {"p_lstm": ..., "p_sgd": ..., "source": "..."}
                p_hybrid, detail = hybrid_model.predict_proba(
                    tabular_df=last_row,
                    seq_df=seq_df,
                    p_sgd=p_sgd,
                )
                p_source = detail.get("source", "HYBRID")
                p_lstm = detail.get("p_lstm")
                system_logger.info(
                    "[HYBRID] p_sgd=%.4f, p_lstm=%s, p_hybrid=%.4f, source=%s",
                    p_sgd,
                    f"{p_lstm:.4f}" if p_lstm is not None else "None",
                    p_hybrid,
                    p_source,
                )
            except Exception as e:
                system_logger.exception(
                    "[HYBRID] HybridModel.predict_proba failed, using SGD only: %r", e
                )
                p_hybrid = p_sgd
                p_source = "ONLINE"

            # 6) Sinyal karar (BUY / SELL / HOLD) -> hibrit skor üzerinden
            BUY_TH = config.BUY_THRESHOLD
            SELL_TH = config.SELL_THRESHOLD

            if p_hybrid >= BUY_TH:
                signal = "BUY"
            elif p_hybrid <= SELL_TH:
                signal = "SELL"
            else:
                signal = "HOLD"

            system_logger.info(
                "[SIGNAL] p_buy=%.4f (source=%s, BUY_THRESHOLD=%.2f, SELL_THRESHOLD=%.2f)",
                p_hybrid,
                p_source,
                BUY_TH,
                SELL_TH,
            )
            system_logger.info("[SIGNAL] Generated trading signal: %s", signal)

            # 7) Risk kontrolü (günlük zarar limiti vs.)
            equity = trade_executor.get_equity()
            allowed, reason = risk_manager.can_open_new_trade(current_equity=equity)
            if not allowed:
                system_logger.warning(
                    "[MAIN] Trading halted for today by risk manager (%s).", reason
                )
                if position_manager.has_open_positions():
                    current_price = float(clean_df["close"].iloc[-1])
                    trade_executor.flatten_all_positions({symbol: current_price})
                await asyncio.sleep(LOOP_SLEEP_SECONDS)
                continue

            # 8) Pozisyon yönetimi
            current_price = float(clean_df["close"].iloc[-1])
            manage_positions_for_signal(
                symbol=symbol,
                signal=signal,
                current_price=current_price,
                trade_executor=trade_executor,
                position_manager=position_manager,
            )

        except asyncio.CancelledError:
            system_logger.info("[MAIN] bot_loop cancelled, exiting loop.")
            break
        except Exception as e:
            system_logger.exception("[MAIN] Error in bot_loop: %r", e)

        await asyncio.sleep(LOOP_SLEEP_SECONDS)


# ──────────────── Entry point ────────────────


async def async_main() -> None:
    trading_objects = create_trading_objects()

    loop_task = asyncio.create_task(bot_loop(trading_objects))

    # Graceful shutdown için sinyal handler
    loop = asyncio.get_running_loop()

    def _cancel_tasks():
        system_logger.info("[MAIN] Shutdown signal received, cancelling bot_loop...")
        loop_task.cancel()

    for sig in (signal.SIGINT, signal.SIGTERM):
        try:
            loop.add_signal_handler(sig, _cancel_tasks)
        except NotImplementedError:
            # Windows için
            pass

    try:
        await loop_task
    finally:
        system_logger.info("[MAIN] Cleanup: cancelling bot_loop task...")


def main() -> None:
    try:
        asyncio.run(async_main())
    except KeyboardInterrupt:
        system_logger.info("[MAIN] KeyboardInterrupt received, exiting.")
    except Exception as e:
        system_logger.exception("[MAIN] Fatal error: %r", e)
        sys.exit(1)


if __name__ == "__main__":
    main()

